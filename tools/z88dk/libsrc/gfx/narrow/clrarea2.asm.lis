/tmp/tmpXXCeCGkN.asm:
     1                          MODULE clrarea2_asm
     2                          LINE 0, "clrarea2.asm"
clrarea2.asm:
                                
     1                          
     2                                  SECTION smc_clib
     3                          
     4                                  PUBLIC  cleararea
     5                          
     6                                  EXTERN  pixeladdress
     7                                  EXTERN  leftbitmask, rightbitmask
     8                          
     9                          ;
    10                          ;    $Id: clrarea2.asm,v 1.6 2017-01-02 21:51:24 aralbrec Exp $
    11                          ;
    12                          
    13                          ; ***********************************************************************
    14                          ;
    15                          ; Clear specified graphics area in map.
    16                          ;
    17                          ; Design & programming by Gunther Strube, Copyright (C) InterLogic 1995
    18                          ;
    19                          ; Generic SMC version by Stefano Bodrato.
    20                          ;
    21                          ;
    22                          ;
    23                          ; IN:    HL    = (x,y)
    24                          ;    BC    = (width,heigth)
    25                          ;
    26                          ; Registers changed after return:
    27                          ;   ......../IXIY same
    28                          ;   AFBCDEHL/.... different
    29                          ;
    30                          
    31                          cleararea:
    32  0000  225f00                    ld      (coord+1), hl           ; SMC: remember y,x
    33  0003  04                        inc     b
    34  0004  c5                        push    bc                      ; remember height
    35  0005  c5                        push    bc
    36  0006  e5                        push    hl
    37  0007  cd0000                    call    pixeladdress            ; bitpos0 = pixeladdress(x,y)
    38  000a  e1                        pop     hl
    39  000b  cd0000                    call    leftbitmask             ; LeftBitMask(bitpos0)
    40  000e  323e00                    ld      (bitmaskl1+1), a        ; SMC
    41  0011  324a00                    ld      (bitmaskl2+1), a        ; SMC
    42  0014  c1                        pop     bc
    43  0015  7c                        ld      a, h
    44  0016  80                        add     b
    45  0017  3d                        dec     a
    46  0018  3d                        dec     a
    47  0019  67                        ld      h, a
    48  001a  d5                        push    de
    49  001b  cd0000                    call    pixeladdress            ; bitpos1 = pixeladdress(x+width-1,y)
    50  001e  cd0000                    call    rightbitmask            ; RightBitMask(bitpos1)
    51  0021  324200                    ld      (bitmaskr1+1), a
    52  0024  325c00                    ld      (bitmaskr2+1), a        ; bitmask1 = LeftBitMask(bitpos0)
    53  0027  e1                        pop     hl
    54  0028  e5                        push    hl                      ; adr0
    55  0029  eb                        ex      de, hl
    56  002a  bf                        cp      a
    57  002b  cd0000                    sbc     hl, de                  ; (adr1-adr0)/8
    58  002e  7d                        ld      a, l
    59  002f  323800                    ld      (rowbytes1+1), a
    60  0032  324e00                    ld      (rowbytes2+1), a        ; rowbytes = (adr1-adr0) div 8, no. of bytes in row
    61                                 ; 0 means that area is within same address
    62                                 ; FOR h = 1 TO height
    63  0035  e1                        pop     hl                      ; adr0
    64                          clear_height:
    65  0036  af                        xor     a
    66                          rowbytes1:
    67  0037  fe00                      cp      0                       ; if rowbytes = 0
    68  0039  c24800                    jr      nz, clear_row           ; area is within one byte...
    69  003c  7e                        ld      a, (hl)
    70                          bitmaskl1:
    71  003d  e600                      and     0                       ; preserve bits of leftmost side of byte
    72  003f  47                        ld      b, a
    73  0040  7e                        ld      a, (hl)
    74                          bitmaskr1:
    75  0041  e600                      and     0                       ; preserve bits of rightmost side of byte
    76  0043  b0                        or      b                       ; merge preserved bits of left side
    77  0044  77                        ld      (hl), a                 ; (offset) = byte
    78  0045  c35e00                    jr      clear_nextrow           ; else
    79                          clear_row:                              ; clear area is defined as rows of bytes
    80  0048  7e                        ld      a, (hl)
    81                          bitmaskl2:
    82  0049  e600                      and     0                       ; preserve only leftmost bits (outside of area)
    83  004b  77                        ld      (hl), a                 ; (offset) = (offset) AND bitmask0
    84  004c  23                        inc     hl                      ; offset += 1 (8 bits)
    85                          rowbytes2:
    86  004d  0600                      ld      b, 0                    ; r = rowbytes
    87  004f  05                        dec     b                       ; --r
    88  0050  ca5a00                    jr      z, row_cleared          ; if    ( r )
    89                          clear_row_loop:                         ; do
    90  0053  3600                      ld      (hl), 0                 ; (offset) = 0
    91  0055  23                        inc     hl                      ; offset += 1 (8 bits)
    92  0056  05c25300                  djnz    clear_row_loop          ; while ( r-- != 0 )
    93                          row_cleared:
    94  005a  7e                        ld      a, (hl)                 ; byte = (adr1)
    95                          bitmaskr2:
    96  005b  e600                      and     0
    97  005d  77                        ld      (hl), a                 ; preserve only rightmost side of byte (outside area)
    98                          
    99                          clear_nextrow:
   100  005e  210000            coord:  ld      hl, 0                   ; SMC -> y,x
   101  0061  2c                        inc     l
   102  0062  225f00                    ld      (coord+1), hl           ; SMC -> y,x
   103  0065  cd0000                    call    pixeladdress
   104  0068  eb                        ex      de, hl                  ; put adr0 in hl for next row
   105                          
   106                                 ; END FOR    h
   107  0069  c1                height: pop     bc
   108  006a  0d                        dec     c                       ; height
   109  006b  c5                        push    bc
   110  006c  c23600                    jr      nz, clear_height
   111  006f  c1                        pop     bc
   112                          
   113                          end_cleararea:
   114  0070  c9                        ret
   115                          
